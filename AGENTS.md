## CODE QUALITY & DESIGN

- Keep Low Cyclomatic Complexity: Avoid deep nesting and complex branching.
- Minimize Cognitive Complexity: Logic should be simple and easy to understand.
- DRY Principle: Reuse logic and UI (avoid duplication unless necessary for admin components).
- High Cohesion: Group related responsibilities inside components.
- Loose Coupling: Components should not rely heavily on others' internal logic.
- Clear Naming: Use meaningful, domain-relevant names for components, functions, variables.
- Single Responsibility Principle: Each component/function should focus on one job.

## SECURITY CONTROLS

### CACHING
MUST set Cache-Control: no-store, no-cache, must-revalidate, Pragma: no-cache, Expires: 0. MUST base cache decisions on HTTP headers, not paths/extensions; include Vary where relevant (e.g., Vary: Origin, Authorization). MUST return 404 for missing resources and perform 302/307 redirects without serving fallback cached content.

### COOKIE-SESSION
ALWAYS secure session management: MUST set session cookies with Secure, HttpOnly, and SameSite (use Lax for auth flows; Strict otherwise). MUST use __Host- prefix with Path=/ and no Domain. MUST enforce CSRF tokens on state-changing requests

### CORS
Configure CORS with an explicit allowlist of trusted origins in Access-Control-Allow-Origin, validate the Origin header against this allowlist, and ensure responses contain no sensitive data when wildcard origins are used.

### DATABASE-INTERACTION

MUST configure all database connections with TLS 1.2+ encryption enabled, set sslmode=require (or equivalent) in connection strings, disable older TLS/SSL versions, and ensure certificate validation is enforced; for CloudSQL, deploy CloudSQL proxy as a sidecar container in Kubernetes deployments, configure applications to connect through localhost proxy endpoints, and use CloudSQL connector libraries for service authentication.
ALWAYS use parameterized queries, prepared statements, or ORM frameworks exclusively for database interactions; NEVER construct SQL queries through string concatenation or interpolation with user input.
MUST create dedicated database users with minimal required permissions for each service, grant only necessary table/column access, and implement row-level security policies where user data segregation is required.

### DESERIALISATION

Avoid deserializing untrusted data entirely; use safer alternatives like JSON.parse() with schema validation, XML parsers with external entity processing disabled (xxe=false), or YAML.safe_load() instead of YAML.load(). When deserialization is required, implement strict input validation, use allow-lists for permitted classes, and consider sandboxing deserialization processes in isolated environments.

### FILE-UPLOAD

MUST Configure file upload limits with MAX_FILE_SIZE environment variable or equivalent configuration, implement file size validation before processing and set appropriate timeout values to prevent resource exhaustion from large file uploads; Implement per-user storage quotas using database constraints or filesystem quotas, track cumulative file sizes per user with periodic cleanup, and enforce limits like 1GB total storage and 100 files maximum per user account using middleware that checks current usage before allowing new uploads; During server-side file processing, use secure extraction methods that ignore or sanitize user-provided path information. Implement path validation to prevent directory traversal by using path.resolve() and ensuring all extracted files remain within designated safe directories using path.relative() checks.
MUST Before extracting compressed files, validate uncompressed size using stream-based decompression with size limits (e.g., 100MB max), count file entries during extraction with maximum file count limits (e.g., 1000 files), and use libraries like node-stream-zip with built-in protection against zip bombs and decompression attacks; During archive extraction, reject compressed files containing symbolic links by checking entry paths for '..' and symbolic link attributes. Use safe extraction libraries like tar-stream with filter functions to validate each entry path and prevent extraction outside designated directories; Validate file types using MIME type detection libraries based on file signatures, not file extensions. Implement allow-lists for permitted MIME types and reject files with mismatched content-type headers versus actual file signatures; Store uploaded files outside web root directory in a dedicated upload directory with restricted permissions (e.g., 644 for files, 755 for directories), disable script execution in upload directories using web server configuration (.htaccess or nginx config), and use separate domains or subdomains for serving user content.
Configure web servers to serve uploaded files with Content-Type: application/octet-stream or other non-executable MIME types, set Content-Disposition: attachment headers to force downloads instead of inline execution, and store uploaded files outside the web root directory with separate static file serving endpoints.

### FRONTEND

MUST Implement HTTP Strict Transport Security (HSTS) by setting the Strict-Transport-Security header with max-age=31536000; includeSubDomains for all HTTPS responses, ensure proper HSTS preload list inclusion for production domains, and configure web servers to include HSTS headers to prevent protocol downgrade attacks; Implement server-side access control enforcement by validating all permissions on backend services, never rely solely on client-side access controls, use secure API endpoints with proper authentication and authorization, and ensure frontend applications cannot bypass server-side security checks through direct API calls; Set proper Content-Type headers for all HTTP responses including charset specification (e.g., "Content-Type: text/html; charset=UTF-8" or "Content-Type: application/json; charset=UTF-8"), ensure content matches the declared Content-Type, and use safe character encodings to prevent content-type confusion attacks; Implement a comprehensive Content Security Policy (CSP) with restrictive directives like "default-src 'self'", specify allowed sources for scripts, styles, and images, use nonce or hash-based CSP for inline scripts, and regularly review and update CSP directives to prevent XSS attacks while maintaining functionality; Implement X-Frame-Options: DENY or SAMEORIGIN headers and CSP frame-ancestors directive to prevent clickjacking attacks, use frame-ancestors 'none' or 'self' in CSP for modern browsers, ensure consistent framing policies across all pages, and test framing protection using tools like browsers' developer console; Set X-Content-Type-Options: nosniff header for all HTTP responses to prevent browsers from MIME-type sniffing and interpreting files as different content types than declared, ensure proper Content-Type headers are set for all resources, and prevent content-type confusion attacks; Implement appropriate Referrer-Policy headers (e.g., "strict-origin-when-cross-origin" or "no-referrer") to prevent sensitive information leakage through HTTP referer headers, consider the balance between functionality and privacy, and ensure sensitive URLs and parameters are not exposed to external sites; Implement anti-caching headers for sensitive pages using "Cache-Control: no-store, no-cache, must-revalidate", "Pragma: no-cache", and "Expires: 0" headers, identify pages containing sensitive data that should not be cached, and ensure browser back-button protection for authenticated pages; Implement URL redirect validation using allow-lists of permitted destination domains, validate redirect URLs against trusted patterns, warn users about external redirects with clear confirmation dialogs, and never perform redirects based solely on user-supplied URLs without validation to prevent open redirect attacks; Prevent prototype pollution by sanitizing object property keys, avoiding unsafe operations like merge() or extend() with user input, using Object.create(null) for safe objects, implementing proper input validation for object properties, and using libraries like lodash with security updates that address prototype pollution; Implement context-aware output encoding for different output contexts (HTML, HTML attributes, JavaScript, CSS, URL), use appropriate encoding functions for each context, ensure encoding happens close to output generation, and use templating engines with automatic escaping enabled to prevent output manipulation attacks; Implement comprehensive XSS protection using context-aware output escaping, Content Security Policy (CSP), and input validation, use libraries like DOMPurify for HTML sanitization, enable auto-escaping in templating engines, validate and sanitize all user inputs, and implement proper encoding for reflected, stored, and DOM-based XSS prevention; Remove or hide server version information from HTTP headers by configuring web servers (nginx, Apache, IIS) to suppress version details, avoid exposing technology stack information in response headers, error pages, or source code comments, and implement generic error pages that don't reveal server details; Implement secure postMessage handling by validating the origin of incoming messages against an allow-list of trusted domains, validate message structure and content using strict parsing, avoid using eval() or similar functions on message data, and implement proper error handling for invalid messages.

Apply the principle of least privilege in frontend applications by showing only UI elements users are authorized to access, implementing role-based UI rendering, restricting access to sensitive frontend routes and components, and ensuring frontend authorization logic complements rather than replaces server-side authorization.
MUST Avoid storing sensitive data in browser storage (localStorage, sessionStorage, IndexedDB, or cookies) except for session tokens which should use secure, HttpOnly cookies or sessionStorage, implement data classification policies for client-side storage, and regularly audit what data is stored client-side; Implement secure session termination by clearing all client-side storage (localStorage, sessionStorage, cookies) upon logout, invalidate server-side sessions, provide explicit logout functionality, and ensure authenticated data is completely removed from browser memory and storage.

### GLOBAL-CRYPTO

MUST use FIPS 140-2 approved cryptographic algorithms for all cryptographic operations, including secure random number generation; for Go services, specifically use Boring Crypto and ensure the presence of the `import _ "crypto/tls/fipsonly"`.
MUST integrate with enterprise secrets management solutions; acceptable solutions include 1Password or AWS Secrets Manager.

### GLOBAL-IAM

MUST enforce server-side authorization at the service layer by validating user permissions against immutable policy stores; use role-based access control (RBAC) with the principle of least privilege; and prevent client-side manipulation of authorization data by storing all access control policies and user attributes server-side in secure databases or identity providers.
ALWAYS restrict administrative interface access using network ACLs, VPN requirements, or IP allow-lists to trusted locations; implement device authentication certificates; require multi-factor authentication (MFA) for all admin access; and use jump hosts or bastion servers for all administrative operations.

### GRAPHQL

MUST implement comprehensive GraphQL authorization at the business logic layer using middleware or resolver-level checks; validate user permissions before executing queries or mutations and before returning data; apply field-level authorization in GraphQL resolvers; use role-based access control to restrict query and mutation access; validate user context in each resolver function; ensure authorization is context-aware, considering the specific data being accessed; and NEVER rely solely on GraphQL schema or schema-level restrictions for security.
ALWAYS implement robust GraphQL query control and rate limiting; enforce query depth limiting (e.g., max 10-15 levels); perform query complexity analysis using

### GRPC

MUST secure all gRPC method execution: implement authentication and authorization using interceptors to validate tokens/credentials and apply role-based access control (RBAC) to restrict method access based on user permissions, ensuring no gRPC method can be called without proper authentication; concurrently, implement comprehensive input validation for all gRPC method parameters using protobuf field validation rules or custom validators, validating data types, ranges, and formats according to the proto schema, and enforce these validation rules consistently across all gRPC methods via interceptors before processing requests.
ALWAYS configure gRPC servers and clients for resilience: set appropriate deadlines and timeouts for all gRPC method calls using `context.WithTimeout()` or `context.WithDeadline()`; implement robust timeout handling in both client and server to prevent resource exhaustion from long-running requests.

### JWT

MUST use strong algorithms for JWT signing, preferring RSA (RS256) or ECDSA (ES256) over HMAC; if HMAC (HS256) is required, generate secrets with at least 64 cryptographically random characters and store them securely.
ALWAYS validate JWTs securely: use the JWT library's verify() method (or equivalent secure function) to ensure signature validation is mandatory for all accepted tokens, never use decode() or similar methods that only parse without verifying; explicitly reject JWTs with alg: "none" in the header, implementing robust parsing that handles case variations and encoding

### MESSAGE-QUEUE

MUST implement schema validation for all message queue messages using Avro, JSON Schema, or Protobuf, validate message structure and content against defined schemas before processing, and configure message brokers to reject messages that don't conform to expected formats or contain invalid data.
ALWAYS secure message queue access and configuration: implement authentication for message queue access using SASL mechanisms with proper credentials (retrieved from Event Bus secrets rather than hardcoded values), ensuring clients authenticate via certificates, API keys, or OAuth tokens and never anonymously; configure ACLs to restrict topic and queue access based on user/service identity, validating all event-bus configurations follow security best practices including proper ACL settings; and configure event-bus custom resources with proper ownership

### NODEJS-API

When building a node.js API: MUST prevent prototype pollution: sanitize keys, avoid unsafe deep merges with untrusted input, use Object.create(null) for dictionaries or Map for user-controlled keys, and check with Object.prototype.hasOwnProperty.call. MUST validate all inputs with schema libraries (e.g., AJV/Joi). Never use eval or dynamic code execution on user input.

### OAUTH

MUST implement robust OAuth token revocation: provide RFC 7009 compliant endpoints; ensure user-accessible revocation controls are available in the UI; and immediately invalidate revoked tokens across all system components.
MUST strictly validate the `redirect_uri` parameter: enforce an allowlist of pre-registered URIs using exact string matching; reject partial matches or pattern-based validation; and ensure all redirect destinations are HTTPS-only.

### OAUTH-CLIENT

ALWAYS validate the "iss" (issuer) parameter in OAuth authorization responses against expected issuer URLs when interacting with multiple Authorization Servers; if "iss" is unavailable, use distinct redirect URIs to differentiate authorization endpoints; implement PKCE (Proof Key for Code Exchange) with code_challenge_method=S256 for public OAuth clients, generating a cryptographically random code_verifier and creating code_challenge using SHA256 hash; or alternatively, use the OpenID Connect "nonce" parameter with secure random values and verify the nonce claim in ID tokens matches the session.
MUST include specific "scope" parameters in OAuth requests to define exactly which resources are accessed; use the "resource" parameter to explicitly specify the target Resource Server URI when supported; use granular "scope" parameters to restrict access tokens to specific resources and actions (e.g., "read:users", "write:documents"); implement "authorization_details" parameter for fine-grained permissions when supported; and ensure access tokens are only valid for the explicitly requested resources and operations.

### REST-API

MUST rigorously validate all incoming REST API requests: enforce `additionalProperties: false` for all OpenAPI schemas; define explicit `pattern`, `enum`, or `format` for all IDs and typed strings, always list `required` fields, set request body size limits at the API gateway/service (e.g., `1 MiB via middleware`); accept only declared `Content-Type` (e.g., `application/vnd.api+json`, rejecting others with `HTTP 415`); ensure GET/HEAD/OPTIONS/TRACE methods are implemented as read-only; and reject requests violating these rules with `400`, `413`, `415`, or `422` HTTP status codes; NEVER expose secrets or PII in paths or query parameters, using headers instead.
MUST enforce strict access control (Principle of Least Privilege) for all REST API endpoints: verify user roles and ownership for every request via authorization middleware; NEVER trust client-supplied IDs, tokens, or headers alone for authorization decisions; ensure both horizontal (user A cannot access user B's data) and vertical (no privilege escalation via parameter tampering) access checks are performed for all CRUD actions (e.g., `GET /users/{user_id}`, `PATCH /orgs/{org_id}/admin`); and reject unauthorized requests with `403` or `404` HTTP status codes.

### REVERSE-PROXY

MUST Configure reverse proxy (nginx, Apache, HAProxy) to enforce TLS 1.2+ only, disable SSL/TLS versions below 1.2, use strong cipher suites, and ensure all client-proxy and proxy-backend communications use encrypted connections with proper certificate validation; Configure reverse proxy with input validation rules using WAF modules or built-in filtering, validate HTTP headers, request methods, URL patterns, and content-type against allow lists, set request size limits, and reject malformed requests before forwarding to backend services; Configure reverse proxy access controls with role-based routing rules, implement path-based access restrictions for sensitive endpoints, use authentication headers to validate user permissions before forwarding requests, and ensure only authorized services can be accessed through specific proxy routes; Implement rate limiting in reverse proxy configuration using modules like nginx limit_req, Apache mod_evasive, or HAProxy stick-tables, set appropriate request rate limits per IP address or user, configure burst limits for legitimate traffic spikes, and return HTTP 429 responses when limits are exceeded.

### SENSITIVE-DATA-HANDLING

Use structured logging libraries that automatically redact sensitive fields, implement data classification tags, configure log retention policies with automatic deletion, avoid logging full request/response bodies, and use placeholder values for sensitive data in error messages. Enable audit trails that track data access without exposing the actual sensitive content.

### TEMPLATE-ENGINE

Use template engines with automatic escaping enabled (e.g., Handlebars with escapeMarkup, Jinja2 with autoescape), sanitize user input with libraries like DOMPurify, avoid eval() or similar dynamic code execution functions, and implement sandboxed template rendering with restricted access to system functions and global variables.

### TOKEN-SESSION

MUST Ensure all session token verification is performed on the server-side using trusted back-end services, never rely on client-side validation alone, implement server-side token validation middleware that checks token authenticity and expiration, and maintain session state securely on the server; Implement stateless token expiration validation by checking the 'exp' claim in JWTs before processing, use server-side timestamp comparison against current time, handle timezone differences correctly, and reject expired tokens with appropriate error responses to prevent session reuse attacks; Implement token revocation mechanisms using blacklists, token versioning, or short-lived tokens with refresh patterns when user roles change, maintain a revocation list that's checked during token validation, use token binding to user sessions, and ensure tokens are invalidated immediately when permissions are modified; Generate session tokens using cryptographically secure random number generators with at least 128 bits of entropy, use libraries like crypto.randomBytes() in Node.js or secrets.token_bytes() in Python, and ensure tokens are sufficiently long and unpredictable to prevent brute force attacks.
Use only strong cryptographic signing algorithms for stateless tokens such as RS256, RS384, RS512, ES256, ES384, or ES512 for JWTs, maintain an allow-list of approved algorithms, reject tokens signed with weak algorithms like HS256 with shared secrets in multi-party scenarios, and regularly rotate signing keys.
Implement comprehensive JWT validation by verifying critical claims including 'iss' (issuer), 'sub' (subject), 'aud' (audience), 'exp' (expiration), and 'iat' (issued at), validate claims against expected values for your application context, use proper claim validation libraries, and reject tokens with missing or invalid security-sensitive attributes.

### USER-INPUT-OUTPUT

MUST Implement comprehensive input validation on user input using allow-lists for expected data types, formats, and ranges, use strong typing for structured data with schema validation (JSON Schema, XML Schema), sanitize unstructured data by restricting allowed characters and enforcing length limits, and validate all input at both client and server sides with server-side validation as the authoritative check; Implement HTTP parameter pollution defenses by standardizing parameter handling across framework components, use frameworks that distinguish parameter sources (GET, POST, cookies, headers), implement parameter deduplication logic, and validate that only expected parameters are processed to prevent parameter pollution attacks; Implement mass assignment protection by using Data Transfer Objects (DTOs) with explicit field mapping, mark sensitive model fields as private or protected, use framework-specific protections like Rails strong parameters or Django ModelForm field restrictions, and never bind request parameters directly to model objects without filtering; Implement comprehensive protection against SSRF, LFI, and RFI by validating and sanitizing all file paths and URLs, use allow-lists for permitted protocols, domains, and paths, implement network segmentation to limit server-side requests, and validate file inclusion operations against expected directories using canonicalization to prevent path traversal; Prevent OS command injection by using parameterized commands, prepared statements, or safe APIs instead of constructing shell commands from user input, implement input validation with strict allow-lists for command parameters, use contextual output encoding for shell contexts, and avoid direct shell execution when possible by using language-specific libraries.
Implement XSS protection by sanitizing and validating user-supplied scriptable content using libraries like DOMPurify for HTML sanitization, disable dangerous HTML tags and attributes in user content, use Content Security Policy to restrict script execution, and implement context-aware output encoding for different output contexts (HTML, JavaScript, CSS).

### WEB-HOOKS

MUST secure all webhook transport and endpoints: configure webhook endpoints to use HTTPS only with TLS 1.2+; validate SSL certificates for webhook delivery; reject HTTP connections; ensure both incoming webhook receivers and outgoing webhook senders use encrypted transport with proper certificate validation; implement authentication for webhook endpoints using API tokens, basic authentication, or bearer tokens; validate authentication credentials before processing webhook payloads; use webhook-specific authentication tokens with limited scope; and log failed authentication attempts for security monitoring.
ALWAYS validate and secure webhook payloads: validate all incoming webhook payloads using strict schema validation (JSON Schema, XML Schema), checking payload structure, data types, and field constraints; implement size limits for webhook payloads; reject webhooks that don't match expected format or contain malicious content; implement webhook signature verification using HMAC-SHA256 or similar cryptographic signatures, validating the signature header (e.g., X-Hub-Signature-256) against the webhook payload using a shared secret; reject unsigned webhooks; use constant-time comparison to prevent timing attacks during signature validation; design webhook payloads to exclude sensitive data such as PII, passwords, API keys, and confidential business information; use webhook identifiers or references instead of actual sensitive data; implement data minimization principles in webhook design; and ensure webhook content follows data protection requirements.

### WEBSOCKETS

MUST Implement comprehensive WebSocket message validation by defining and enforcing strict message schemas using JSON Schema or similar validation frameworks, validate message structure, data types, size limits, and content against expected formats, and reject malformed or oversized WebSocket messages before processing; Configure WebSocket connections to use WebSocket Secure (WSS) protocol exclusively, ensure all WebSocket communications are encrypted using TLS 1.2 or higher, validate SSL certificates properly, and reject any attempts to establish unencrypted WebSocket connections to prevent network sniffing and man-in-the-middle attacks; Implement Origin header validation during WebSocket handshake by maintaining an allow-list of authorized origins, verify the Origin header matches expected domains before establishing WebSocket connections, implement CORS-like origin checking for WebSockets, and reject handshake requests from unauthorized or missing origins; Implement WebSocket rate limiting by tracking message frequency per client connection, set maximum messages per second/minute limits per user or IP address, use token bucket or sliding window algorithms for rate limiting, and close WebSocket connections that exceed rate limits while logging potential abuse attempts; Generate WebSocket session tokens using approved cryptographic algorithms with sufficient entropy (minimum 128 bits), use secure random number generators for token creation, implement proper token rotation and expiration mechanisms, and ensure WebSocket-specific tokens follow the same security standards as HTTP session tokens; Ensure WebSocket tokens are obtained only through secure POST requests over HTTPS, never transmit tokens directly through WebSocket message content, use HTTP-only secure cookies or Authorization headers for token delivery, and implement proper token handling that separates authentication from WebSocket message data; Implement pre-authentication for WebSocket connections by requiring users to authenticate via HTTP before establishing WebSocket connections, validate authentication tokens during WebSocket handshake, maintain authenticated session state throughout the WebSocket connection lifecycle, and reject WebSocket connection attempts from unauthenticated users; Implement role-based access control for WebSocket communications by validating user permissions for specific WebSocket operations, restrict access to sensitive WebSocket endpoints based on user roles, implement message-level authorization checks, and ensure the principle of least privilege is applied throughout WebSocket message handling and routing.

### XML-PROCESSING

MUST configure XML parsers to disable external entity processing; disable DTD processing; and disable XInclude.
ALWAYS secure XPath queries by using parameterized XPath queries or XPath compilation with bound variables; sanitize user input before XPath construction; and avoid dynamic XPath string concatenation with untrusted data.
